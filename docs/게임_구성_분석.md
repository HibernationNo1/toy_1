## 상위 규칙 문서

```
1. 게임 핵심 루프 정의
- 유저가 반복하게 될 행동, 그로 인해 증가하는 요소, 다시 행동을 유도하는 연결 구조를 명확히 정의
- 한 문장으로 “무엇을 반복하고 왜 계속하는지” 설명 가능해야 함
- 이 루프가 흔들리면 UI·가챠·마켓 전부 무력화됨

2. 기본 행동(Core Action) 명확화
- 게임에서 가장 단순하고 반복되는 행동을 명확히 규정
- 기본 행동이 막히면 게임이 멈추는 구조인지 점검
- 버튼, 보상, 성장, 난이도는 모두 이 행동을 중심으로 설계

3. 저연령·초보자 친화 로블록스 UI/피드백 설계
- UI는 ‘설명’이 아니라 ‘행동’을 발생시키는 장치로 설계하고, 읽지 않아도 기본 행동이 즉시 실행되게 만든다
- 다음 행동은 항상 1개만 강조하며, 실패·지연·무효 입력 상황에서도 즉각적인 피드백으로 흐름이 끊기지 않게 유지한다
- 불안(모름/되돌릴 수 없음/실수 공포)을 제거하는 방향으로 UI 상태·전환·거래·확인 단계를 설계해 “계속해도 된다”는 신뢰를 만든다

4. 성장 설계(체감 중심)
- 숫자보다 변화(이펙트, 속도, 크기, 화면 반응)로 성장을 느끼게 설계
- 실패해도 “조금은 강해졌다”는 감각 유지
- 단기·중기·장기 성장의 시각적 차별 필요

5. 경제 구조 설계(재화·가챠·마켓)
- 재화의 생성과 소멸 경로 명확화
- 꽝의 정의, 실패 시 남는 요소, 인플레이션 방지 구조 준비
- 초보자 보호와 고인물 독점 방지 장치 포함

6. 데이터 저장·복구 설계(DataStore)
- 저장 대상, 저장 시점, 실패 시 대처 명확화
- 데이터 손실 시 유저 경험 붕괴 방지 구조 필요
- 저연령 환경에서는 데이터 안정성이 곧 신뢰

7. 악용·트롤·파괴 행위 대비
- 재화 복사, 가챠 악용, 마켓 테러 가능성 사전 고려
- 완벽 차단보다 피해 확산 방지에 집중
- 자유를 주되 시스템적으로 한계 설정

8. 성능·기기 편차 대응
- 모바일·저사양·불안정 네트워크 환경 고려
- 프레임 드랍·지연 상황에서도 행동 가능 상태 유지
- 로컬 반응과 서버 결과 분리 설계

9. 업데이트·확장 계획
- 콘텐츠 추가 시 기존 구조가 무너지지 않는지 점검
- 아이템·스테이지·시스템 확장 여지 확보
- 장기 운영을 전제로 한 설계 필요

10. 로블록스 플랫폼 제약 이해
- 저작권, 저연령 보호, 확률형 아이템 정책 숙지
- 이미지·사운드·과금 관련 제한 파악
- 정책 미숙지는 삭제·제재로 직결
```

## 

### 규칙 템플릿

```
[섹션명]
- 한 문장 정의 + 별칭
  · 이 섹션이 무엇을 다루는지 1문장으로 고정
  · 반드시 ‘행동/구조/연결/유지’ 중 하나의 키워드를 포함
  예)
    - 게임 핵심 루프 정의 – “행동이 다시 행동을 낳는 연결 구조”
    - 기본 행동(Core Action) – “모든 시스템이 수렴하는 단 하나의 입력”
    - 성장 설계 – “반복을 정당화하는 체감 장치”
    - 경제 구조 – “행동의 가치를 순환시키는 교환 시스템”
    - 데이터 저장 – “신뢰를 기술적으로 보증하는 바닥”
    - 성능·기기 대응 – “행동 연속성을 보존하는 안전망”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션이 반드시 필요한 이유를 서술
- 이 항목이 무너질 경우 게임 전체에서 발생하는
  ‘구조적 실패’를 명확히 규정
- 다른 시스템(UI, 성장, 경제, 온보딩 등)을
  어떤 기준으로 정렬시키는지 설명

작성 규칙:
- 철학적 수사 금지
- “없으면 무엇이 망가지는가”만 다룬다
- 유저 감정이 아니라 시스템 붕괴를 기준으로 서술

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 결정되어야 하는 결과물 목록

예시 구조:
1) 1문장 핵심 정의
2) 실행 조건 또는 성립 조건
3) 차단 요소 목록 + 제거 원칙
4) 충돌 시 우선순위 기준
5) 판별 체크리스트(Yes/No)

규칙:
- 최소 3개, 최대 5개
- 추상적 목표 금지
- “판단 가능 상태”로 끝나야 함

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 이 섹션의 절대 원칙을 한 줄로 선언
- 예외 없음 / 타협 없음 / 논쟁 불가

예)
- “이 구조가 멈추면 게임은 더 이상 진행되지 않는다”
- “이 행동이 막히는 순간, 모든 보상 시스템은 의미를 잃는다”

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────
실행 가능한 규칙만 나열한다.
설명 ❌ / 판단 기준 ⭕ / 조건 명시 ⭕

구성:
1) 실행 규칙
  · 반드시 지켜야 하는 설계 조건
2) 금지 규칙
  · 이 섹션의 목적을 훼손하는 설계 패턴
3) 조건부 허용 규칙
  · 허용되지만 반드시 붙는 제약 조건

작성 원칙:
- “왜” 설명하지 않는다
- “어길 경우 어떤 구조가 깨지는지”로 규칙을 지지
- 행동 단위, 시스템 단위로 서술

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
- 이 섹션의 모든 규칙이
  최종적으로 보호하려는 단 하나의 가치 명시

대부분 아래 둘 중 하나로 귀결됨:
- 행동 지속
- 불안 제거

예)
→ 이 규칙들의 목적은
  유저가 ‘멈출 이유’를 갖지 않게 만드는 것이다

────────────────────────────────
D) 금지 예시 / 허용 예시 (선택)
────────────────────────────────
- 설계자의 사고를 즉시 교정하기 위한 장치
- 실제 현장에서 자주 발생하는 실패 사례 위주

형식:
❌ 금지 예시
  - 구조적으로 왜 실패하는지 한 줄 첨언

⭕ 허용 예시
  - 어떤 조건을 만족하기 때문에 허용되는지 명시

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 다른 섹션과 충돌할 때 무엇이 최우선인지 명시
- 회의용이 아니라 설계 결정용 규칙

형식:
- A < B
- C보다 D가 항상 우선

예)
- 연출 완성도 < 행동 반복성
- 밸런스 엄격함 < 기본 행동 실행 가능성

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 예외를 인정하지 않는다
- 예외 상황이 생기면 ‘구조를 어떻게 바꿀지’를 제시

형식:
- “~한 경우 예외” ❌
- “~한 경우 구조를 이렇게 단순화/대체” ⭕

예)
- 중반 이후 다른 행동이 더 많이 반복된다면:
  → 기본 행동 정의 자체를 재검토한다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 이 섹션의 정의가 한 문장으로 설명 가능한가?
- 이 구조가 막히면 게임 진행이 사실상 정지되는가?
- 다른 시스템이 이 섹션을 기준으로 정렬되는가?
- 실패/지연/변형 상황에서도 대체 경로가 존재하는가?
- 설계자가 아닌 제3자가 봐도 판단이 가능한가?

→ 하나라도 No라면
  이 섹션은 다시 정의되어야 한다
```





###  1. 게임 핵심 루프 정의

```
[섹션명]
- 게임 핵심 루프 정의
  – “행동이 다시 행동을 낳는 연결 구조”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  게임에서 ‘무엇이 반복되는지’를 감각이나 장르가 아니라
  구조적으로 고정하는 것이다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 유저 행동이 단발성 이벤트로 흩어짐
  · 성장, 가챠, 마켓이 서로 다른 리듬으로 작동
  · UI가 무엇을 강조해야 하는지 기준 상실
  · 보상은 존재하지만 “다시 할 이유”가 사라짐
  · 콘텐츠 추가 시마다 게임 방향이 흔들림

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · UI: 무엇을 가장 크게, 자주 노출해야 하는가
  · 기본 행동: 무엇이 루프의 최소 단위인가
  · 성장 설계: 무엇을 반복해야 강해지는가
  · 경제/가챠/마켓: 어떤 행동에서 가치가 발생하는가
  · 온보딩: 처음 30초에 무엇을 경험시켜야 하는가

→ 핵심 루프는
  “재미 요소”가 아니라
  **모든 시스템을 한 방향으로 묶는 중심축**이다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 게임 핵심 루프를 설명하는 1문장 정의
2) 루프를 구성하는 반복 단위(행동 → 결과 → 유도)
3) 루프를 차단하는 요소 목록 + 제거 원칙
4) 루프와 다른 시스템이 충돌할 때의 우선순위
5) “이게 루프인가?” 판별 체크리스트

※ 이 산출물은 기획서용 문장이 아니라
   설계 판단을 위한 기준표다

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 이 루프가 끊기는 순간,
  게임은 더 이상 ‘게임’으로 작동하지 않는다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 핵심 루프는 반드시 ‘행동 → 결과 → 다음 행동 유도’의
  3단 구조를 가져야 한다
  · 행동에서 끝나는 구조 금지
  · 결과에서 멈추는 구조 금지
  · 반드시 다시 행동으로 연결되어야 한다

- 핵심 루프는 한 문장으로 설명 가능해야 한다
  · “이 게임은 ○○을 반복해서 △△해지기 때문에 계속한다”
  · 설명이 두 문장을 넘으면 루프 정의 실패

- 핵심 루프의 반복 단위는 짧아야 한다
  · 5초~30초 안에 한 번 이상 완결되는 구조
  · 스테이지 클리어, 챕터 완료 단위 금지
  → 루프가 길어질수록 이탈 포인트 증가

- 핵심 루프는 모든 주요 보상의 출발점이어야 한다
  · 성장, 재화, 가챠 재료, 거래 가능 아이템 등
  · 루프를 거치지 않고 얻는 보상 남발 금지
  → 루프는 경제의 근원이다

- 핵심 루프는 실패해도 다시 시작 가능해야 한다
  · 실패 = 루프 중단 ❌
  · 실패 = 루프 재진입 ⭕
  → 실패가 루프를 끊으면 구조 붕괴

2) 금지 규칙

- “콘텐츠 소비”를 루프로 정의하는 것
  · 예: 스테이지 클리어, 스토리 감상
  → 소모 구조는 반복 구조가 아니다

- “보상 수령”을 루프의 끝으로 두는 것
  → 보상 수령은 다음 행동의 시작점이어야 한다

- 여러 개의 루프를 병렬 핵심 루프로 두는 것
  → 루프가 둘 이상이면
    시스템은 반드시 분열된다

3) 조건부 허용 규칙

- 보조 루프(서브 루프)는 허용한다
  · 단, 반드시 핵심 루프를 강화하거나
    핵심 루프의 효율을 높이는 방향이어야 한다
  · 핵심 루프를 대체하는 순간 제거 대상

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 모든 규칙은
  유저가 “왜 다시 해야 하지?”라는 질문을
  구조적으로 떠올리지 않게 만드는 데 있다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- “이 게임의 핵심 루프는 스테이지를 클리어하는 것이다”
  → 실행 단위가 크고, 실패 시 루프 차단

❌ 금지 예시
- “전투 → 보상 획득 → 종료”
  → 다음 행동 유도 부재

⭕ 허용 예시
- “버튼을 눌러 전투를 발생시키고,
   그 결과로 재화를 얻어
   다시 더 강한 전투를 하게 된다”
  → 행동-결과-유도 명확

⭕ 허용 예시
- “맵에서 오브젝트를 상호작용해
   즉시 보상을 얻고,
   그 보상으로 더 효율적인 상호작용을 하게 된다”
  → 반복 단위 짧고, 성장 직결

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- UI 연출 < 핵심 루프 반복성
- 밸런스 엄격함 < 핵심 루프 지속성
- 콘텐츠 다양성 < 핵심 루프 명확성
- 세계관 연출 < 핵심 루프 연결성

즉,
- 루프가 흔들리면
  다른 모든 요소는 수정 또는 제거 대상이다

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- “중반 이후 다른 행동이 더 중요해진다”는 경우:
  → 실제 반복 로그 기준으로
    핵심 루프 정의를 재검토한다

- “루프가 너무 단순해 보인다”는 경우:
  → 단순한 루프 위에
    복잡한 결과를 얹는 것이 설계다
  → 루프 자체를 복잡하게 만드는 것은 해결책이 아니다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 이 게임의 핵심 루프가 한 문장으로 설명 가능한가?
- 한 번의 루프가 30초 안에 완결되는가?
- 실패해도 루프에 즉시 재진입 가능한가?
- 모든 주요 보상이 이 루프에서 시작되는가?
- UI·성장·경제가 이 루프를 기준으로 정렬되는가?

→ 하나라도 No라면
  이 게임은 아직 ‘핵심 루프’를 갖지 못했다
```



### 2. 기본 행동(Core Action) 명확화

```
[섹션명]
- 기본 행동(Core Action) 명확화
  – “모든 시스템이 수렴하는 단 하나의 입력”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  게임 내 수많은 기능과 선택지 중
  “이것만은 반드시 반복된다”는
  단 하나의 행동을 구조적으로 고정하는 것이다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 유저가 무엇을 해야 하는지 매 순간 판단해야 함
  · 버튼, 메뉴, 시스템이 서로 경쟁하는 상태 발생
  · 성장·보상·경제의 기준점 상실
  · 난이도 조정이 불가능해짐
  · UI가 ‘도구’가 아니라 ‘장벽’이 됨

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · UI: 가장 크게 보여야 할 버튼은 무엇인가
  · 성장: 무엇을 반복하면 강해지는가
  · 보상: 어떤 행동에 보상이 붙는가
  · 난이도: 무엇을 기준으로 쉬움/어려움을 조절하는가
  · 온보딩: 처음 10초에 무엇을 시켜야 하는가

→ 기본 행동은
  “플레이 스타일”이 아니라
  **게임을 멈추지 않게 하는 생존 조건**이다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 기본 행동을 설명하는 1문장 정의
2) 기본 행동의 실행 조건(언제/어떻게 가능한가)
3) 기본 행동을 차단하는 요소 목록 + 제거 원칙
4) 다른 행동과 충돌 시의 우선순위 기준
5) “이게 기본 행동인가?” 판별 체크리스트

※ 이 산출물은
   UI·경제·성장 설계의 기준점으로 사용된다

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 이 기본 행동이 막히는 순간,
  게임은 즉시 정지 상태에 들어간다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 기본 행동은 반드시 ‘단일 입력’으로 정의되어야 한다
  · 하나의 버튼, 하나의 터치, 하나의 조작
  · 복합 조작, 연속 입력 금지
  → 저연령·초보자 기준에서
    “생각 없이 누를 수 있어야 한다”

- 기본 행동은 언제나 실행 가능해야 한다
  · 재화 부족, 쿨타임, 조건 미달로
    완전히 막히는 상태 금지
  · 효과가 약해질 수는 있으나
    입력 자체는 항상 허용되어야 한다
  → 입력 차단 = 행동 중단

- 기본 행동은 모든 성장의 출발점이어야 한다
  · 경험치, 재화, 아이템, 강화 재료 등
  · 어떤 형태로든
    기본 행동을 하지 않으면
    성장이 발생하지 않아야 한다
  → 우회 성장 경로는 구조 붕괴를 만든다

- 기본 행동은 실패해도 반복 가능해야 한다
  · 실패 시 손실 최소화
  · 즉시 재시도 가능 상태 유지
  → 실패가 학습이 되지 않으면
    반복은 멈춘다

- 기본 행동은 게임 전체에서 가장 많이 반복된다
  · 로그 기준으로
    다른 어떤 행동보다
    실행 횟수가 많아야 한다
  → 많이 반복되지 않는 행동은
    기본 행동이 아니다

2) 금지 규칙

- “강화”, “구매”, “뽑기”를 기본 행동으로 정의하는 것
  → 이는 보조 행동이며
    반복 지속 구조를 만들지 못한다

- 상황에 따라 기본 행동이 바뀌는 구조
  → 기준점이 이동하는 순간
    UI·난이도·보상 설계가 붕괴된다

- 기본 행동을 설명해야 이해되는 구조
  → 설명이 필요한 행동은
    기본 행동 자격을 상실한다

3) 조건부 허용 규칙

- 기본 행동의 ‘결과 다양화’는 허용한다
  · 입력은 동일하되
    결과가 성장에 따라 달라지는 구조
  → 입력은 고정, 결과만 확장

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 모든 규칙은
  유저가 “지금 뭘 해야 하지?”라는
  질문을 떠올릴 필요 자체를 제거하는 데 있다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- “이 게임의 기본 행동은
   상황에 맞게 포탑을 선택해 설치하는 것이다”
  → 판단 부담 발생
  → 초보자 구간에서 행동 정지

❌ 금지 예시
- “재화가 있어야만 행동 가능”
  → 재화 고갈 = 게임 중단

⭕ 허용 예시
- “화면 중앙의 버튼을 눌러
   즉시 전투/행동을 발생시킨다”
  → 판단 불필요
  → 입력 단순

⭕ 허용 예시
- “어디를 눌러도
   동일한 기본 행동이 실행된다”
  → 오입력에도 구조 유지

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 기본 행동 실행 가능성 < 어떤 요소도 우선하지 않는다
- UI 미관 < 기본 행동 접근성
- 밸런스 엄격함 < 기본 행동 지속성
- 전략 다양성 < 기본 행동 명확성

즉,
- 기본 행동이 흔들리면
  다른 모든 설계는 수정 대상이다

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 중반 이후 다른 행동이 더 자주 반복된다면:
  → 그 행동이 실제 기본 행동이므로
    정의를 교체한다

- 숙련 유저가 기본 행동을 무시하는 경우:
  → 기본 행동의 보상 구조를 강화한다
  → 행동 자체를 복잡하게 만들지 않는다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 이 게임의 기본 행동이 한 문장으로 설명 가능한가?
- 입력 하나로 실행 가능한가?
- 재화·조건 없이 항상 실행 가능한가?
- 실패해도 즉시 다시 시도 가능한가?
- 다른 모든 시스템이 이 행동을 기준으로 설계되는가?

→ 하나라도 No라면
  이 게임은 아직 ‘기본 행동’을 정의하지 못했다
```



### 3. 저연령·초보자 친화 로블록스 UI/피드백 설계

```
[저연령·초보자 친화 로블록스 UI/피드백 설계]
1. 기본 철학
2. 핵심 목표
3. UI 설계 절대 원칙
4. 입력–반응 규칙
5. 필수 피드백 3종 세트
6. UI 구성 기준 – 버튼 수는 3개 이하
7. 온보딩(초기 진입) 규칙 – ‘0초 시작’ 설계
8. 학습 곡선·막힘 방지 규칙 – ‘포기 지점 제거’
9. 경제·보상·마켓 규칙 – ‘신뢰 유지 구조’
10. 환경 차이·지연·오류 대응 규칙 – ‘철학 붕괴 방지’

------------------------------------
1. 기본 철학
- UI는 설명 도구가 아니라 행동 유도 장치다
  · UI의 목적은 이해를 돕는 것이 아니라
    행동을 발생시키는 것이다
  · 설명이 필요해지는 순간, UI는 이미 실패한 상태다
  · “알게 만드는 UI”가 아니라
    “누르게 만드는 UI”만을 목표로 한다

- 유저는 읽지 않고, 보이는 것에 반응한다
  · 텍스트 해석을 전제로 한 설계는 배제한다
  · 색, 크기, 위치, 움직임이 언어보다 우선한다
  · 읽지 않아도 행동이 발생해야 한다
  → 인식은 시각으로, 판단은 본능으로 일어나야 한다

- 이해시키려 하지 말고 누르게 만들어라
  · ‘왜 해야 하는지’를 설명하지 않는다
  · ‘지금 해야 할 것’을 보여준다
  · 설득, 안내, 튜토리얼 중심 사고를 버린다
  → 행동이 먼저이고, 이해는 나중에 따라온다

- UI는 항상 정답 하나만 보여준다
  · 동시에 여러 선택지를 제시하지 않는다
  · 지금 이 순간의 최적 행동 하나만 강조한다
  · 나머지는 숨기거나 존재감을 제거한다
  → 고민이 생기는 UI는 저연령 친화 UI가 아니다

- 실패는 행동의 일부이며, 멈춤의 이유가 아니다
  · 실패는 경고나 처벌이 아니다
  · 실패는 또 하나의 피드백이다
  · 실패 후에도 즉시 다음 행동이 가능해야 한다
  → 실패가 게임의 리듬을 끊어서는 안 된다

- UI는 유저의 불안을 제거해야 한다
  · 불안의 원인은 대부분 ‘모름’과 ‘되돌릴 수 없음’이다
  · UI는 항상 “괜찮다, 계속해도 된다”를 전달해야 한다
  · 위험, 손실, 실수에 대한 공포를 자극하지 않는다
  → 안정감은 행동 지속의 전제 조건이다

- UI는 유저가 ‘통제하고 있다’는 느낌을 줘야 한다
  · 자동으로 바뀌는 화면, 예고 없는 변화는 불안을 만든다
  · 모든 변화는 유저 입력의 결과로 인식되어야 한다
  · 유저는 시스템에 끌려가는 존재가 아니라
    시스템을 작동시키는 주체여야 한다

- UI는 유저를 시험하지 않는다
  · 기억력, 이해력, 추론력을 요구하지 않는다
  · 실수 가능성을 전제로 설계한다
  · “잘못 누를 수 있음”을 당연한 전제로 둔다
  → 유저를 검증하는 UI는 저연령 UX와 정면 충돌한다

- UI는 행동을 ‘멈추는 이유’를 만들지 않는다
  · 복잡함, 두려움, 망설임, 부담은 모두 제거 대상이다
  · 유저가 손을 떼는 순간은
    UI가 실패한 순간이다
  → 목표는 ‘행동의 시작’이 아니라 ‘행동의 지속’이다
---

2. 핵심 목표

- 설명 없이 30초 내에 ‘기본 행동’ 수행 가능
  · 튜토리얼, 안내 문장, 도움말을 보지 않아도
    30초 안에 게임의 가장 기본적인 행동이
    실제로 발생해야 한다
  · “무엇을 해야 하는지 알았다”가 아니라
    “이미 해버렸다”가 기준
  · 기본 행동은 UI를 이해한 결과가 아니라
    UI에 반응한 결과여야 한다
  → 첫 행동 지연은 곧 이탈로 직결된다

- 버튼 고민 없이 즉시 행동 반복
  · 어떤 버튼을 눌러야 할지
    머릿속에서 선택이 일어나면 실패
  · 손이 먼저 움직이고
    생각은 나중에 따라와야 한다
  · 버튼은 ‘선택지’가 아니라
    ‘당연한 다음 단계’로 인식되어야 한다
  → 고민이 없는 반복 행동이 목표

- “내가 해서 결과가 났다”는 인식 제공
  · 모든 결과는 유저 행동과
    시간적으로 즉시 연결되어야 한다
  · 자동 발생, 지연 발생, 누적 발생 금지
  · 결과는 반드시 시각·청각적으로
    명확하게 드러나야 한다
  → 시스템이 아니라 ‘나’가 한 일이라는 인식이 핵심

- 행동 → 행동 → 행동이 끊기지 않음
  · 하나의 행동이 끝나면
    다음 행동이 자동으로 보이게 한다
  · 멈춤 화면, 대기 상태, 선택 강요 금지
  · 행동 사이에 판단 공백이 생기지 않도록 설계
  → 게임의 리듬은 행동의 연속성으로 유지된다

- 현재 상태를 읽지 않아도 느낄 수 있음
  · 숫자, 텍스트, 설명으로 상태를 전달하지 않는다
  · 강해짐 / 약해짐 / 부족함 / 충분함은
    색, 크기, 속도, 연출로 체감되게 한다
  · “이해했다”가 아니라
    “느껴진다”가 목표
  → 인식 비용을 제거할수록 행동은 빨라진다

- 실패 후에도 즉시 다시 행동 가능
  · 실패 시 정지, 경고, 확인 단계 금지
  · 실패는 흐름 속의 한 프레임으로 처리
  · 다시 누를 수 있는 상태로
    즉각 복귀해야 한다
  → 실패가 ‘중단’으로 느껴지면 핵심 목표 붕괴

- 행동의 결과는 항상 긍정적 피드백을 남긴다
  · 성공뿐 아니라 실패에도
    최소한의 반응은 반드시 제공
  · 아무 일도 안 일어나는 순간을 만들지 않는다
  → “시스템이 나를 보고 있다”는 감각 유지

- 행동 반복이 곧 성장으로 인식되게 할 것
  · 강화, 수치 증가, 연출 변화 등
    어떤 형태로든 ‘앞으로 나아갔다’는 신호 제공
  · 성장은 나중에 계산하는 개념이 아니라
    매 행동마다 체감되는 감각이어야 한다
  → 반복의 이유를 설명하지 않아도 반복하게 만든다

- 행동을 멈추는 목표를 만들지 않는다
  · “여기까지 하면 된다”는 종료 신호 제거
  · 목표 달성 후에도
    자연스럽게 다음 행동이 이어지도록 설계
  → 핵심 목표는 ‘완료’가 아니라 ‘지속’

---
3. UI 설계 절대 원칙

- 텍스트 최소화
  · 설명 문장 금지
  · 확인·강조용 단어만 사용
  · 읽어야 이해되는 UI는 실패한 UI로 간주

- 항상 다음 행동은 1개만 강조
  · 동시에 여러 버튼을 강조하지 않는다
  · 색, 크기, 애니메이션, 사운드 등 모든 강조 수단은
    ‘지금 반드시 해야 할 행동 하나’에만 집중
  → 시선 경쟁 제거, 판단 비용 제거

- 행동 가능 상태만 보이게 할 것
  · 눌러도 안 되는 버튼, 아직 쓸 수 없는 기능은
    숨기거나 비활성화
  · “왜 안 되는지” 설명하지 않는다
  → 보이는 것은 곧 가능한 것이라는 신뢰 형성

- UI 상태 변화는 항상 ‘이전 행동’의 결과로만 발생
  · 자동 팝업, 예고 없는 화면 전환 금지
  · 유저 입력 없이 UI가 바뀌지 않도록 설계
  → “내가 눌러서 바뀌었다”는 인과관계 인식 강화

- 화면 중앙에서 결과가 발생해야 함
  · 숫자 튐, 이펙트, 강화 결과, 성공/실패 반응은
    항상 화면 중앙 또는 중앙 근처에서 발생
  · 화면 가장자리에는 핵심 피드백 배치 금지
  → 시선 이동 최소화, 즉각적 인식 보장

- 실패해도 흐름이 끊기지 않도록 설계
  · 실패 시 정지 화면, 강제 확인 팝업, 긴 연출 금지
  · 즉시 다음 행동 가능 상태로 복귀
  → 실패가 ‘중단’이 아니라 ‘과정’이 되도록 설계

- 행동 실패에도 반드시 반응을 제공
  · 실패 = 아무 일도 안 일어남 ❌
  · 실패 = 색 변화, 짧은 애니메이션, 다른 사운드 ⭕
  → 실패도 시스템이 인식했다는 안정감 제공

- UI는 항상 ‘되돌릴 수 있다’는 느낌을 줘야 함
  · 돌이킬 수 없는 선택처럼 보이는 연출 금지
  · 경고, 확인, 취소 개념을 UI에서 제거
  → 저연령 유저의 핵심 공포 요소 제거

- 애니메이션·소리로 본능적 유도
  · 성공, 강화, 획득, 설치 등 모든 긍정 행동에
    즉각적인 시각·청각 반응 제공
  · 반응 지연은 버그로 인식됨
  → 입력 → 반응은 즉시

- 숫자·아이콘·게이지는 증가 방향만 명확히 표현
  · 감소, 손실, 복잡한 변동 표현 최소화
  · 커진다 / 차오른다 / 터진다 같은
    단순하고 직관적인 변화만 사용
  → 성장 체감 강화, 좌절 요소 제거

- 같은 행동은 항상 같은 위치·같은 모양·같은 반응
  · 버튼 위치 이동 금지
  · 연출 랜덤화 금지
  · 성공/실패 반응의 규칙성 유지
  → 근육 기억 형성, 생각 없이 누르기 가능

- UI는 유저의 불안을 제거하는 장치여야 함
  · 헷갈림, 망설임, 선택 부담이 생기는 순간
    UI는 실패한 상태
  · “괜찮다, 계속해도 된다”는 메시지를
    말이 아니라 연출로 전달
---

4. 입력–반응 규칙

- 입력 → 시각/청각 반응 ≤ 0.1초
  · 버튼 클릭, 터치, 키 입력 등
    모든 입력은 0.1초 이내에
    최소한의 시각 또는 청각 반응을 발생시켜야 한다
  · 실제 게임 결과(데미지, 설치, 강화)는
    늦게 적용되어도 상관없다
  · 중요한 것은 ‘결과’가 아니라
    “입력이 인식되었다”는 즉각적 신호다
  → 0.1초를 넘는 순간, 유저는 시스템을 의심하기 시작한다

- 입력 직후 반드시 1차 반응이 먼저 발생해야 한다
  · 서버 처리, 계산, 애니메이션 이전에
    로컬 수준의 즉각 반응을 먼저 보여준다
  · 눌렀을 때:
    색 변화 / 눌림 연출 / 소리 중
    최소 하나는 즉시 발생해야 한다
  → 실제 처리가 늦어도 ‘체감 속도’는 유지해야 한다

- 지연은 ‘버그’로 인식됨
  · 저연령·초보자 유저는
    지연을 시스템 사정으로 해석하지 않는다
  · “왜 늦지?”가 아니라
    “안 눌렸나?”, “고장 났나?”로 인식한다
  · 한 번이라도 이런 인식이 생기면
    이후 모든 지연이 불안 요소로 누적된다
  → 지연은 UX 문제가 아니라 신뢰 붕괴 문제다

- 모든 행동에는 즉각적인 피드백이 필수
  · 성공/실패/불가 여부와 상관없이
    입력에는 반드시 반응이 있어야 한다
  · 아무 일도 일어나지 않는 순간은
    가장 강력한 이탈 트리거다
  → “시스템이 나를 보고 있다”는 감각 유지가 핵심

- 1차 반응과 2차 결과를 분리할 것
  · 1차 반응: 즉각적, 짧음, 가벼움
    (버튼 눌림, 소리, 미세한 이펙트)
  · 2차 결과: 실제 게임 결과
    (공격 발동, 설치 완료, 수치 변화)
  · 두 단계를 명확히 분리하면
    시스템 지연을 감각적으로 숨길 수 있다
  → 체감 반응 속도는 실제 처리 속도보다 중요하다

- 반복 입력에도 항상 동일한 반응을 제공할 것
  · 같은 행동을 10번, 100번 눌러도
    반응의 속도·강도·연출은 동일해야 한다
  · 첫 반응만 빠르고 이후 느려지는 패턴 금지
  → 근육 기억과 신뢰는 ‘일관성’에서 형성된다

- 입력이 무효일 때도 반응은 제공해야 한다
  · 조건 미달, 재화 부족, 쿨타임 등으로
    실제 행동이 실행되지 않더라도
    입력 자체에 대한 반응은 필요하다
  · 예:
    회색 깜빡임, 짧은 음, 작은 흔들림
  → “안 된다”를 설명하지 말고 느끼게 한다

- 입력과 반응 사이에 다른 연출을 끼우지 말 것
  · 팝업, 안내, 전환 화면이
    입력 직후 반응을 가로막아서는 안 된다
  · 반응 → 결과 → 추가 연출 순서 유지
  → 입력과 반응의 인과관계가 흐려지면
    UI 신뢰도는 급격히 하락한다

- 입력 실패는 반응 실패보다 낫다
  · 잘못된 반응 ❌
  · 반응 없음 ❌❌❌
  · 과한 반응 ⭕
  → 과잉 피드백은 조절 가능하지만,
    무반응은 복구 불가능한 불신을 만든다
---

5. 필수 피드백 3종 세트

- 시각 피드백: 행동의 결과를 ‘눈으로 즉시 인식’하게 할 것
  · 모든 행동에는 반드시 시각적 변화가 따라야 한다
  · 숫자 튐, 색 변화, 간단한 이펙트 중
    최소 하나는 항상 발생해야 한다
  · 시각 피드백은 ‘정보 전달’이 아니라
    “뭔가 일어났다”는 사실을 알려주는 신호다
  · 정확한 수치나 의미는 나중 문제이며,
    우선은 변했다는 느낌이 먼저 와야 한다
  → 눈에 보이지 않는 결과는
    유저에게 존재하지 않는 결과와 같다

- 시각 피드백은 즉각적이고 짧아야 한다
  · 긴 애니메이션, 화려한 연출은 필수 아님
  · 0.1초 이내에 시작되고,
    0.5초 이내에 끝나는 것이 이상적
  · “봤다”는 인식만 남기고
    다음 행동을 방해하지 않아야 한다
  → 피드백은 감탄용이 아니라 행동 연결용이다

- 숫자 피드백은 ‘변화 방향’만 명확히 보여줄 것
  · +, -, 증가, 폭발, 팽창 같은
    직관적 방향성이 핵심
  · 정확한 계산이나 비교를 요구하지 않는다
  · 숫자를 읽게 만들면 피드백이 아니라 UI가 된다
  → 느끼는 것이 읽는 것보다 우선한다

- 청각 피드백: 행동이 시스템에 인식되었음을 ‘귀로 확정’할 것
  · 클릭, 설치, 강화, 성공, 실패 등
    주요 행동에는 반드시 소리가 있어야 한다
  · 소리는 결과 설명이 아니라
    “입력이 접수되었다”는 확인 도장이다
  · 화면을 보지 않아도
    행동이 성공했음을 알 수 있어야 한다
  → 청각 피드백은 시각 피드백의 백업 수단이다

- 청각 피드백은 짧고 반복 가능해야 한다
  · 길거나 웅장한 사운드는 피로를 만든다
  · 수십, 수백 번 들어도
    거슬리지 않는 길이와 음색 사용
  · 같은 행동에는 같은 소리를 사용해
    조건 반사 수준으로 인식되게 한다
  → 소리는 학습이 아니라 습관을 만든다

- 성공/실패의 청각 구분은 ‘질’로만 표현
  · 성공 = 밝음, 상승, 짧음
  · 실패 = 둔함, 낮음, 짧음
  · “실패음”이 불쾌하거나 위협적이어서는 안 된다
  → 실패를 경고하지 말고 구분만 하라

- 시간 피드백: 누르자마자 반응
  · 시각 또는 청각 피드백은
    입력 직후 즉시 발생해야 한다
  · 실제 게임 결과가 늦어지더라도
    피드백은 먼저 나와야 한다
  · 반응이 늦으면 유저는
    결과가 아니라 입력 자체를 의심한다
  → 체감 반응 속도는 실제 처리 속도보다 중요하다

- 3종 피드백은 반드시 ‘세트’로 작동해야 한다
  · 시각만 있음 ❌
  · 청각만 있음 ❌
  · 즉각성만 있음 ❌
  · 최소 조건은:
    ‘보였다 + 들렸다 + 즉시였다’
  → 이 세 가지 중 하나라도 빠지면
    행동 인식은 불완전해진다

- 실패 행동에도 동일한 3종 피드백 적용
  · 실패했다고 해서
    피드백을 생략하지 않는다
  · 실패도 행동의 결과이므로
    동일한 피드백 구조를 유지
  → “실패해도 시스템은 나를 보고 있다”는 신뢰 유지

- 피드백은 행동을 멈추지 않게 해야 한다
  · 피드백 연출이
    다음 입력을 가로막아서는 안 된다
  · 피드백은 항상
    다음 행동 위에 겹쳐서 발생
  → 피드백은 멈춤 장치가 아니라 연결 장치다

- 과한 피드백보다 위험한 것은 ‘무피드백’이다
  · 피드백이 없으면
    유저는 행동을 반복하지 않는다
  · 피드백이 있으면
    과해도 조절할 수 있다
  → 무반응은 즉시 이탈을 만든다
---

6. UI 구성 기준 – 버튼 수는 3개 이하

- 버튼 수는 항상 3개 이하로 제한한다
  · 화면에 동시에 인식 가능한 버튼은
    최대 3개를 넘지 않아야 한다
  · 4개 이상이 되는 순간,
    유저는 ‘행동’이 아니라 ‘선택’을 시작한다
  → 선택이 시작되면 행동은 멈춘다

- 버튼은 ‘기능 목록’이 아니라 ‘행동 흐름’이다
  · 버튼은 메뉴가 아니다
  · 버튼은 지금 이 순간
    유저가 할 수 있는 행동의 순서다
  · 3개 버튼은 곧:
    이전 행동 / 현재 행동 / 다음 행동
  → 버튼은 구조를 보여주는 장치다

- 버튼의 수보다 중요한 것은 ‘행동 역할’이다
  · 3개 버튼이 모두 다른 역할을 가져야 한다
  · 같은 행동 성격의 버튼이
    둘 이상 존재하면 즉시 통합 대상
  예)
    ❌ 강화1 / 강화2 / 강화3
    ⭕ 강화 / 닫기
  → 기능 분산은 저연령 UI의 최대 적이다

- 버튼은 동시에 ‘동등한 중요도’를 가지면 안 된다
  · 3개 이하라 해도
    모두 같은 크기·색·위치면 실패
  · 항상 하나의 버튼만
    시각적·공간적으로 가장 크고 눈에 띄어야 한다
  → 버튼 수 제한의 목적은
    ‘강조 대상 하나’를 만들기 위함이다

- 가장 중요한 버튼은 항상 ‘기본 행동 버튼’이다
  · 이 게임에서 성장을 발생시키는
    가장 단순한 행동이
    가장 큰 버튼이어야 한다
  · 다른 버튼은 보조 수단이지
    경쟁 대상이 아니다
  → 기본 행동 버튼은
    고민 없이 누를 수 있어야 한다

- 보조 버튼은 언제든 사라질 수 있어야 한다
  · 상황에 따라
    버튼 수는 1개 또는 2개까지 줄어들 수 있어야 한다
  · ‘항상 3개를 채워야 한다’는 강박 금지
  → 적을수록 항상 더 안전하다

- 버튼이 필요한지 먼저 의심할 것
  · 어떤 기능은 버튼이 아니라
    자동 처리 또는 행동 결과로 충분할 수 있다
  · “이 버튼이 없으면 게임이 멈추는가?”
    아니라면 제거 대상
  → 버튼은 최후의 수단이다

- 버튼은 설명을 요구해서는 안 된다
  · 버튼 의미를 텍스트로 설명해야 한다면
    그 버튼은 이미 실패한 상태
  · 아이콘, 위치, 크기, 반응만으로
    눌러도 될 것임을 느끼게 해야 한다
  → 버튼은 읽는 대상이 아니라
    누르는 대상이다

- 버튼 간 거리는 충분히 확보할 것
  · 버튼 수가 적을수록
    버튼 간 간격은 더 넓어야 한다
  · 오입력 가능성은
    저연령 UI에서 치명적이다
  → 실수 가능성은 설계 책임이다

- 버튼 위치는 절대 이동하지 않는다
  · 버튼 수가 줄어들어도
    주요 버튼의 위치는 고정
  · 위치 기억이 깨지는 순간
    근육 기억은 무효화된다
  → 버튼 수 제한은
    ‘위치 안정성’과 함께 작동해야 한다

- 버튼 제거는 숨김으로 처리한다
  · 버튼이 사라질 때
    갑작스럽게 사라지지 않는다
  · 흐릿해지거나
    자연스럽게 빠지는 연출 사용
  → UI 변화조차 불안을 만들지 않게 설계

- 버튼 수 제한은 저연령만을 위한 규칙이 아니다
  · 숙련 유저일수록
    버튼 수가 적을 때 더 빠르게 행동한다
  · 버튼이 많아질수록
    숙련도는 UI 복잡성에 잡아먹힌다
  → 버튼 수 제한은
    전체 유저층의 효율을 동시에 높인다
---
7. 온보딩(초기 진입) 규칙 – ‘0초 시작’ 설계

- 시작 화면에서 즉시 ‘기본 행동’이 가능해야 한다
  · 로딩 후 튜토리얼, 안내, 설명 화면을 거치지 않는다
  · 화면에 진입하는 즉시
    기본 행동 버튼이 보이고, 눌릴 수 있어야 한다
  → 시작 지연은 곧 이탈로 직결된다

- 첫 10초는 실패가 없는 구간으로 설계한다
  · 첫 행동은 무조건 성공하거나
    실패해도 성공처럼 인식되게 설계
  · 저연령 유저는 초반 실패를
    ‘내 실수’가 아니라 ‘게임 문제’로 받아들인다
  → 초반에는 실력 검증을 하지 않는다

- 첫 행동은 설명이 아니라 환경으로 유도한다
  · 화살표, 반짝임, 진동, 크기 변화로 유도
  · “여기를 눌러라” 같은 문장 최소화
  → 텍스트 없는 유도만 허용

- 첫 행동의 결과는 과장되어도 괜찮다
  · 실제 효과보다
    더 크고 더 화려한 피드백 허용
  · “내가 뭔가 했다”는 인식을
    강하게 각인시키는 것이 목적
  → 초반은 정확함보다 확신이 우선이다

- 첫 행동 이후 즉시 다음 행동이 보이게 한다
  · 첫 행동이 끝나면
    다음 행동 버튼이 자동으로 강조
  · 행동 간 공백 금지
  → 온보딩은 연속된 행동 흐름이다
---
8. 학습 곡선·막힘 방지 규칙 – ‘포기 지점 제거’

- 유저가 막히는 순간을 UI로 해결하려 하지 않는다
  · 팝업, 설명, 도움말로 막힘을 해결하지 않는다
  · 막힘은 시스템(난이도/보상/속도)에서 제거한다
  → UI는 막힘을 덮는 도구가 아니다

- 성장 체감은 숫자가 아니라 변화로 제공한다
  · 공격 속도, 이펙트 크기, 화면 반응 등
    감각적 변화가 먼저 와야 한다
  · 숫자는 보조 정보일 뿐 핵심이 아니다
  → “강해졌다”는 느낌이 즉시 와야 한다

- 막혔을 때 선택지를 늘리지 않는다
  · 강화, 상점, 뽑기, 퀘스트를
    동시에 제시하지 않는다
  · 막힘 해결을 위한 행동은 항상 하나만 남긴다
  → 막힌 유저에게 선택은 부담이다

- 막힘 해결 행동은 자동으로 강조된다
  · 막힘 상태에서는
    ‘정답 행동’만 크게, 밝게, 눈에 띄게
  · 다른 버튼은 숨기거나 약화
  → “이걸 하면 된다”를 고민 없이 느끼게 한다

- 재시도 비용은 거의 없어야 한다
  · 실패 후 큰 손실 금지
  · 시간, 재화, 아이템 손실 최소화
  → 재도전이 쉬울수록 포기는 줄어든다
---

9. 경제·보상·마켓 규칙 – ‘신뢰 유지 구조’

- 보상은 항상 예고된 후 지급되어야 한다
  · 완전한 블라인드 보상 최소화
  · “곧 뭔가 나온다”는 신호 제공
  → 예측 가능성은 불안을 줄인다

- 가챠는 결과보다 행동 유지를 위해 존재한다
  · 뽑기 결과에서 멈추지 않게 설계
  · 결과 직후:
    다시 뽑기 / 강화 / 판매 / 다음 행동이
    즉시 가능해야 한다
  → 뽑기는 정지 지점이 아니라 연결 지점이다

- 가챠 실패에도 반드시 긍정적 잔여가 남아야 한다
  · 완전한 ‘꽝’ 금지
  · 재화, 누적 포인트, 교환 재료 등
    다음 행동으로 이어지는 요소 제공
  → 실패가 무의미하게 느껴지면 신뢰가 무너진다

- 마켓은 자유보다 안전을 우선한다
  · 가격 입력은 완전 자유가 아니라
    합리적 범위 내에서만 가능
  · 극단적 가격으로 인한 혼란 방지
  → 저연령 환경에서 자유 시장은 위험하다

- 마켓 UI는 가격 판단을 ‘느낌’으로 돕는다
  · 텍스트 설명 대신
    범위 표시, 색상, 위치로
    비싸다/싸다를 직관적으로 전달
  → 읽지 않아도 판단 가능해야 한다

- 실수 거래는 되돌릴 수 있어야 한다
  · 실수 구매/판매에 대한
    완전한 복구 또는 완화 장치 제공
  · 경고 팝업으로 책임을 넘기지 않는다
  → 불안 없는 거래가 핵심이다

---
10. 환경 차이·지연·오류 대응 규칙 – ‘철학 붕괴 방지’

- 로컬 반응과 서버 결과를 반드시 분리한다
  · 입력 직후 로컬 1차 반응은 항상 즉시 발생
  · 서버 결과는 나중에 반영 가능
  → 체감 반응 속도가 신뢰를 결정한다

- 느린 환경에서도 ‘행동 가능 상태’를 유지한다
  · 로딩 화면에 유저를 가두지 않는다
  · 결과가 늦어도
    입력과 반응은 계속 가능해야 한다
  → 기다리게 만드는 순간 이탈이 발생한다

- 지연은 숨기지 말고 분산한다
  · 긴 대기 시간 대신
    여러 짧은 반응으로 쪼갠다
  · “기다림”이 아니라
    “진행 중”으로 느끼게 한다
  → 시간 인식이 핵심이다

- 오류는 메시지가 아니라 피드백으로 처리한다
  · “네트워크 오류” 같은 문장 최소화
  · 실패 피드백 + 즉시 재시도 구조로 대체
  → 오류 설명은 불안을 키운다

- 어떤 상황에서도 ‘아무 반응 없음’을 만들지 않는다
  · 실패, 지연, 오류 상황에서도
    최소한의 시각/청각 반응 제공
  → 무반응은 즉시 신뢰 붕괴를 만든다

- 환경 문제를 유저 책임으로 느끼게 하지 않는다
  · 느림, 실패, 오류가
    유저 탓처럼 보이지 않게 설계
  · 항상 “괜찮다, 계속해도 된다”는 흐름 유지
  → 저연령 UX의 최종 방어선이다
```





### 4. 성장 설계(체감 중심)

```
[섹션명]
- 성장 설계(체감 중심)
  – “반복을 정당화하는 변화 유지 구조”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  유저가 ‘더 해야 할 이유’를
  계산이나 비교 없이 즉각적으로 느끼게 만드는 것이다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 행동을 반복해도 달라진 느낌이 없음
  · 성장 결과를 숫자로 읽어야만 인식 가능
  · 실패 시 손해만 남아 행동 중단 발생
  · 성장 정체 구간에서 루프 이탈
  · 가챠·강화·마켓이 동기 유발 기능을 상실

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · 기본 행동: 반복할수록 무엇이 달라지는가
  · UI/피드백: 변화가 어디서 어떻게 보이는가
  · 난이도: 성장이 체감되지 않는 구간이 있는가
  · 경제/보상: 성장이 언제 보상으로 전환되는가

→ 성장은 숫자가 아니라
  **행동을 계속하게 만드는 증거**다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 성장의 1문장 정의(무엇이 어떻게 변하는가)
2) 성장 체감이 발생하는 최소 단위
3) 성장 차단 요소 목록 + 제거 원칙
4) 단·중·장기 성장의 시각적 구분 기준
5) 성장 실패 여부 판별 체크리스트

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 유저가 느끼지 못한 성장은
  시스템적으로 존재하지 않는 성장이다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 성장은 반드시 ‘변화’로 먼저 나타나야 한다
  · 이펙트 크기
  · 공격/행동 속도
  · 화면 반응 빈도
  · 타격감, 반동, 연출 밀도
  → 숫자 증가는 보조 정보로만 존재한다

- 성장 체감은 매 행동 단위에서 발생해야 한다
  · 레벨업, 구간 클리어 단위 금지
  · 행동을 1번 했을 때
    최소한의 변화라도 발생해야 한다
  → 반복의 즉각적 보상이 핵심이다

- 실패 후에도 성장 신호는 남아야 한다
  · 실패 = 정지 ❌
  · 실패 = 약하지만 누적되는 변화 ⭕
  → “헛되지는 않았다”는 감각 유지

- 성장은 기본 행동의 효율을 직접 바꿔야 한다
  · 데미지 수치만 상승 ❌
  · 행동 속도 증가 ⭕
  · 범위 확대 ⭕
  · 연출 밀도 증가 ⭕
  → 성장 = 행동 감각 변화

- 성장 결과는 화면 중앙에서 발생해야 한다
  · 주변 UI, 메뉴 안쪽에 숨기지 않는다
  · 행동이 일어나는 바로 그 위치에서
    변화가 보이게 설계
  → 시선 이동이 생기면 체감이 끊긴다

2) 금지 규칙

- 숫자를 읽어야만 알 수 있는 성장
  → 저연령·초보자에게 성장 미인지 발생

- 실패 시 손실만 남는 성장 구조
  → 반복 동기 즉시 붕괴

- 특정 시점 이후
  장시간 변화가 없는 구간
  → 성장 정체 = 루프 이탈 지점

- 성장 결과를 메뉴/상태창에만 표시
  → 행동과 성장의 연결 단절

3) 조건부 허용 규칙

- 숫자 표시는 허용하되
  반드시 변화 이후에만 노출
  → ‘느낀 다음에 읽게’ 한다

- 장기 성장은
  단기·중기 성장 위에만 얹는다
  → 장기 목표만으로는 반복이 유지되지 않는다

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 모든 규칙은
  유저가 “아직 더 해볼 만하다”는
  감각을 잃지 않게 만드는 데 있다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- 공격력 +1 (표시만 존재)
  → 변화 인식 불가, 성장 체감 실패

❌ 금지 예시
- 실패 시 보상 0
  → 반복 정당성 붕괴

⭕ 허용 예시
- 공격 속도 미세 증가 + 이펙트 강화
  → 즉각적 변화 인식 가능

⭕ 허용 예시
- 실패 시
  다음 행동에서 이펙트 밀도 증가
  → 누적 성장 감각 유지

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 수치 정확성 < 변화 체감
- 밸런스 엄밀성 < 성장 인식 빈도
- 장기 설계 < 단기 체감 유지
- 계산 가능성 < 즉각적 변화

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- “너무 빨리 강해진다”는 우려가 생기면:
  → 수치를 낮춘다
  → 변화 빈도는 유지한다

- 중반 이후
  성장이 잘 느껴지지 않는다면:
  → 성장 수치를 조정하지 않는다
  → 변화 방식(속도/범위/연출)을 추가한다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 행동 1회 후 달라진 점이 즉시 보이는가?
- 실패해도 “아무것도 안 남았다”는 느낌이 없는가?
- 숫자를 읽지 않아도 성장 여부를 느낄 수 있는가?
- 단기·중기·장기 성장이 시각적으로 구분되는가?
- 성장이 멈추면 행동도 멈추는 구조인가?

→ 하나라도 No라면
  이 성장 설계는 다시 정의되어야 한다
```





### 5.  경제 구조 설계(재화·가챠·마켓)

```
[섹션명]
- 경제 구조 설계(재화·가챠·마켓)
  – “행동의 가치를 순환·유지시키는 교환 구조”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  유저의 행동이 멈추지 않도록
  ‘얻음 → 사용함 → 다시 행동함’의 순환을
  강제로 유지하는 것이다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 재화를 모아도 쓸 이유가 사라짐
  · 가챠 결과에서 행동이 정지됨
  · 초보자는 고갈되고, 고인물은 독점함
  · 인플레이션으로 보상 가치 붕괴
  · 마켓이 행동 촉진이 아닌 스트레스 요인이 됨

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · 기본 행동: 무엇을 하면 재화가 생기는가
  · 성장 설계: 재화 사용이 어떤 변화를 만드는가
  · UI/피드백: 보상과 손실이 어떻게 인식되는가
  · 온보딩: 초반에 무엇을 잃지 않게 보호하는가

→ 경제는 ‘보상’이 아니라
  **행동을 다시 시작시키는 장치**다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 재화별 생성·소멸 경로 1문장 정의
2) ‘꽝’의 구조적 정의(무엇이 남는가)
3) 인플레이션 방지 메커니즘
4) 초보자 보호 / 고인물 제한 규칙
5) 경제 붕괴 판별 체크리스트

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 이 경제 구조에서
  행동 없이 재화가 쌓이거나,
  재화 사용 후 행동이 끊기면
  설계는 실패다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 모든 재화는 ‘행동’에서만 생성된다
  · 출석, 보상 지급, 자동 누적 금지
  · 기본 행동 또는 그 파생 행동만 허용
  → 행동과 재화의 연결을 끊지 않는다

- 모든 재화는 반드시 ‘소멸 경로’를 가진다
  · 쌓이기만 하는 재화 금지
  · 사용처가 없으면 존재 이유 없음
  → 소멸은 벌이 아니라 순환 장치다

- 가챠는 결과가 아니라 다음 행동으로 이어져야 한다
  · 가챠 화면에서 멈춤 ❌
  · 결과 직후:
    강화 / 재도전 / 교환 / 재가챠 ⭕
  → 가챠는 정지 지점이 아니다

- ‘꽝’은 결과가 아니라 상태로 정의한다
  · 완전 무보상 금지
  · 누적 포인트, 교환 재료, 다음 확률 상승 등
    반드시 잔여가 남아야 한다
  → 실패는 손실이 아니라 지연이다

- 마켓은 행동 가치를 재배치하는 도구다
  · 투기, 차익, 독점 중심 설계 금지
  · 행동으로 얻은 가치를
    다른 행동으로 전환시키는 용도만 허용
  → 마켓은 금융 시스템이 아니다

2) 금지 규칙

- 행동을 건너뛰고 재화를 직접 지급하는 구조
  → 행동 루프 즉시 붕괴

- 재화 사용 후
  아무 변화도 없는 구조
  → 경제 무의미화

- 고인물이 재화를 영구 축적할 수 있는 구조
  → 초보자 진입 차단 발생

- 초반에 재화 고갈로
  행동이 막히는 구조
  → 온보딩 단계에서 즉시 이탈

3) 조건부 허용 규칙

- 무료 지급 재화는 허용하되
  반드시 행동 효율을 낮은 수준으로만 증가
  → 행동 대체 금지

- 마켓 자유 거래는 허용하되
  가격·수량·빈도에 상한 필수
  → 독점·테러 방지

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 모든 규칙은
  유저가 “아직 쓸 게 남아 있다”는
  이유로 행동을 멈추지 않게 만드는 데 있다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- 가챠 결과: 아무것도 없음
  → 행동 단절, 신뢰 붕괴

❌ 금지 예시
- 재화 대량 보유 = 절대적 우위
  → 신규 유저 진입 불가

⭕ 허용 예시
- 가챠 실패 시:
  누적 포인트 + 다음 가챠 효율 상승
  → 실패도 다음 행동을 만든다

⭕ 허용 예시
- 마켓에서
  행동 재화 ↔ 성장 재화 교환
  → 플레이 스타일 전환 허용

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 경제 자유도 < 행동 지속성
- 고인물 만족 < 초보자 생존
- 희소성 연출 < 재시도 가능성
- 단기 수익 < 구조 안정성

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 재화가 너무 많이 쌓인다면:
  → 보상을 줄이지 않는다
  → 소멸 경로를 추가한다

- 고인물이 시장을 장악한다면:
  → 거래 자유를 늘리지 않는다
  → 상한·쿨타임·구간 분리를 적용한다

- 초보자가 항상 부족하다면:
  → 지급을 늘리지 않는다
  → 사용 비용을 낮춘다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 모든 재화의 생성·소멸 경로가 명확한가?
- 가챠 실패 후에도 다음 행동이 즉시 가능한가?
- 재화를 써도 손해만 남는 구간이 존재하지 않는가?
- 초보자와 고인물이 같은 시장에서 파괴적 충돌을 하지 않는가?
- 경제가 멈추면 행동도 멈추는 구조인가?

→ 하나라도 No라면
  이 경제 구조는 다시 설계되어야 한다
```



### 6.  데이터 저장·복구 설계(DataStore)

```
[섹션명]
- 데이터 저장·복구 설계(DataStore)
  – “신뢰를 기술적으로 유지하는 행동 보존 구조”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  유저의 행동 결과가
  기술적 이유로 ‘사라지지 않도록’ 보장하는 것이다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 행동해도 남지 않는다는 인식 발생
  · 성장·경제 설계가 모두 무의미해짐
  · UI/피드백 신뢰 즉시 붕괴
  · 저연령 유저 기준: “게임이 거짓말한다”는 인식 형성
  · 단 1회 손실로도 장기 이탈 발생

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · 기본 행동: 어떤 행동의 결과를 반드시 보존할 것인가
  · 성장 설계: 무엇이 ‘되돌릴 수 없는 진전’인가
  · 경제 구조: 어떤 재화가 절대 소실되면 안 되는가
  · 오류 대응: 실패 시 무엇을 먼저 복구할 것인가

→ 데이터 저장은 기능이 아니라
  **행동 신뢰의 최하단 기반**이다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 저장 대상의 명확한 분류(필수/비필수)
2) 저장 시점 규칙(언제 반드시 저장되는가)
3) 저장 실패 시 대체·복구 흐름
4) 데이터 손실 시 보상 또는 완충 규칙
5) 데이터 신뢰 붕괴 판별 체크리스트

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 유저가 ‘했다’고 인식한 행동의 결과는
  어떤 상황에서도 사라져서는 안 된다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 저장 대상은 ‘유저 인식 기준’으로 정의한다
  · 내부 계산값 기준 ❌
  · 유저가 얻었다고 느낀 결과 ⭕
  → 체감 기준이 저장 기준이다

- 저장 대상은 반드시 2단계로 분류한다
  · 절대 보존 데이터:
    성장 단계, 핵심 재화, 해금 상태
  · 완충 가능 데이터:
    임시 보상, 연출용 수치, 반복 소모 자원
  → 모든 데이터를 동일하게 다루지 않는다

- 저장 시점은 행동 종료 시점과 분리한다
  · 화면 전환, 결과 연출 종료를
    저장 기준으로 삼지 않는다
  · “결과가 발생한 순간”이 저장 기준이다
  → 연출 중 오류에도 결과는 남아야 한다

- 저장은 누적보다 단위 보존을 우선한다
  · 10번 행동 후 1회 저장 ❌
  · 1번 행동당 1회 저장 ⭕
  → 손실 규모를 최소화한다

- 저장 성공 여부는 유저에게 묻지 않는다
  · 확인 팝업, 저장 중 알림 금지
  · 저장은 시스템 책임이다
  → 불안을 유저에게 전가하지 않는다

2) 금지 규칙

- 저장 실패 시
  아무 일도 없었던 것처럼 진행 ❌
  → 신뢰 즉시 붕괴

- 네트워크 문제를
  유저 책임처럼 보이게 하는 UI ❌
  → 저연령 UX 치명적

- 재접속 시
  마지막 행동 자체가 사라지는 구조 ❌
  → 행동 가치 붕괴

- 저장 대상과 비저장 대상의
  기준이 불명확한 설계 ❌
  → 복구 정책 불가능

3) 조건부 허용 규칙

- 저장 지연은 허용하되
  반드시 로컬 임시 보존 필수
  → 서버 실패 시 복구 경로 확보

- 일부 데이터 롤백은 허용하되
  유저 인식 기준 ‘핵심 진전’은 제외
  → 체감 손실 금지

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 모든 규칙은
  유저가 “내가 한 것은 남는다”는
  확신을 잃지 않게 만드는 데 있다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- “네트워크 오류로 보상이 지급되지 않았습니다”
  → 유저 기준: 게임이 약속을 어김

❌ 금지 예시
- 재접속 후
  마지막 강화·획득 기록 소실
  → 성장 설계 전면 붕괴

⭕ 허용 예시
- 서버 실패 시:
  임시 지급 + 다음 접속 시 정산
  → 손실 인식 제거

⭕ 허용 예시
- 저장 불가 상황:
  결과는 즉시 반영,
  동기화는 지연 처리
  → 체감 보존 우선

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 데이터 무결성 < 유저 인식 보존
- 성능 최적화 < 손실 방지
- 서버 안정성 < 행동 결과 보존
- 기술적 깔끔함 < 신뢰 유지

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 저장 빈도가 너무 높아 부담된다면:
  → 저장 대상을 줄이지 않는다
  → 저장 단위를 더 작게 쪼갠다

- 서버 오류가 잦다면:
  → 보상 지급을 줄이지 않는다
  → 로컬·중간 캐시 구조를 강화한다

- 일부 악용 가능성이 보인다면:
  → 저장을 막지 않는다
  → 사후 검증·회수 구조를 추가한다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 유저가 ‘얻었다’고 느낀 모든 것이 저장 대상인가?
- 저장 실패 시에도 행동 결과는 보존되는가?
- 단 1회 오류로 장기 이탈이 발생할 가능성이 제거되었는가?
- 데이터 손실이 발생해도 복구 또는 완충 경로가 존재하는가?
- 저연령 유저 기준에서도 “게임이 거짓말했다”는 인식이 생기지 않는가?

→ 하나라도 No라면
  이 데이터 저장 구조는 다시 설계되어야 한다
```





### 7. 악용·트롤·파괴 행위 대비

```
[섹션명]
- 악용·트롤·파괴 행위 대비
  – “자유를 유지한 채 붕괴를 확산시키지 않는 안전 구조”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  악의적 행위를 ‘완전히 없애는 것’이 아니라
  시스템 전체가 무너지는 것을 방지하는 데 있다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 소수 유저의 악용이 경제 전체를 오염시킴
  · 정상 유저의 노력 가치가 상대적으로 붕괴
  · 마켓·가챠·성장 설계가 불공정하다고 인식됨
  · “열심히 해도 의미 없다”는 집단 인식 확산
  · 악용 유저보다 정상 유저가 먼저 이탈

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · 경제 구조: 재화 가치가 왜 유지되는가
  · 성장 설계: 노력 대비 결과의 신뢰성
  · 데이터 저장: 되돌릴 수 있는 범위의 정의
  · UI/피드백: 제재·제한이 어떻게 인식되는가

→ 악용 대비는 보안이 아니라
  **정상 플레이의 의미를 지키는 구조 설계**다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 핵심 악용 시나리오 목록(재화/가챠/마켓)
2) 피해 확산 차단 지점 정의
3) 악용 성공 시에도 시스템이 버티는 완충 규칙
4) 제재·제한 적용 우선순위 기준
5) 악용 붕괴 여부 판별 체크리스트

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 악용은 발생할 수 있지만,
  그 결과가 시스템 전체로 확산되어서는 안 된다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 악용 가능성은 “행동 단위”로 식별한다
  · 코드 단위 ❌
  · 기능 단위 ❌
  · 유저 행동 시나리오 단위 ⭕
  → 악용은 항상 행동에서 시작된다

- 모든 핵심 재화는 상한 또는 감쇠 구조를 가진다
  · 무제한 증식 구조 금지
  · 획득량 증가 시 효율 감소 구조 필수
  → 폭발적 격차 방지

- 가챠·보상 시스템에는
  반복 실행 감쇠 규칙을 반드시 둔다
  · 짧은 시간 내 반복 시
    효율·가치·전환율 감소
  → 자동화·매크로 억제

- 마켓은 자유 시장이 아니라
  ‘완충된 교환 구조’로 설계한다
  · 가격 무제한 입력 금지
  · 거래 빈도·수량·범위 제한
  → 테러성 거래 방지

- 악용 탐지는 사전 차단보다
  사후 복구 가능성에 초점을 둔다
  → 완벽 탐지는 목표가 아니다

2) 금지 규칙

- “완벽 차단”을 목표로 한 설계 ❌
  → 정상 플레이까지 위축됨

- 악용 방지를 이유로
  정상 유저 행동을 복잡하게 만드는 UI ❌
  → 체감 손실이 더 큼

- 악용 유저의 존재를
  시스템 메시지로 드러내는 구조 ❌
  → 집단 불신 유발

- 단일 실패로
  전체 경제가 오염되는 구조 ❌
  → 구조 설계 실패

3) 조건부 허용 규칙

- 일부 악용 성공은 허용한다
  · 단, 누적·확산·전이 불가 조건 필수
  → 피해는 국소화한다

- 의심 행동은 즉시 차단하지 않고
  ‘비효율화’로 대응 가능
  → 오탐 리스크 최소화

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 목적은
  악용 유저를 이기는 것이 아니라
  정상 유저가 손해 보지 않게 만드는 것이다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- 재화 복사 버그 발생 시
  전체 서버 롤백
  → 정상 유저 피해 극대화

❌ 금지 예시
- 마켓 가격 완전 자유
  → 소수 유저에 의한 가격 파괴

⭕ 허용 예시
- 이상 거래 발생 시
  해당 거래군만 격리·동결
  → 전체 신뢰 유지

⭕ 허용 예시
- 반복 가챠 시
  점진적 효율 감소
  → 자동화 무력화

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 정상 유저 신뢰 < 악용 유저 편의
- 피해 확산 방지 < 완벽 차단
- 구조 안정성 < 개별 공정성 논쟁
- 시스템 생존 < 단일 유저 불만

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 악용이 빈번해진다면:
  → 기능을 막지 않는다
  → 결과 효율을 낮춘다

- 정상 유저도 불편을 느낀다면:
  → 제한을 완화하지 않는다
  → 제한이 작동하는 지점을 뒤로 미룬다

- 고인물 독점이 발생한다면:
  → 보상을 깎지 않는다
  → 교환·전환 속도를 늦춘다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 단일 악용 성공으로 경제 전체가 흔들리는가?
- 악용 유저보다 정상 유저가 더 큰 불편을 겪는가?
- 피해가 특정 행동·계정·구간에 국한되는가?
- 복구·격리·완충 경로가 명확히 존재하는가?
- 정상 유저가 “공정하지 않다”보다
  “그래도 할 만하다”를 먼저 느끼는가?

→ 하나라도 No라면
  이 악용 대응 구조는 다시 설계되어야 한다
```



### 8. 성능·기기 편차 대응

```
[섹션명]
- 성능·기기 편차 대응
  – “행동 연속성을 어떤 환경에서도 유지하는 안전 구조”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  모든 유저가 동일한 성능을 경험하게 만드는 것이 아니라,
  어떤 환경에서도 ‘행동이 끊기지 않게’ 만드는 데 있다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 저사양/모바일 유저의 행동 중단
  · 입력 후 무반응 → 시스템 불신
  · “내 탓이 아닌 것 같다”는 좌절 인식
  · 성능 문제를 실력·이해 부족으로 오인
  · 핵심 루프 진입 전 이탈 발생

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · UI/피드백: 지연 상황에서도 반응을 어떻게 보장하는가
  · 기본 행동: 언제든 실행 가능 상태가 유지되는가
  · 온보딩: 첫 10초에 성능 차이가 드러나지 않는가
  · 경제/보상: 성능 차이가 수익 차이로 증폭되지 않는가

→ 성능 대응은 기술 문제가 아니라
  **행동 지속을 보장하는 구조 설계 문제**다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 최소 성능 기준에서도 가능한 ‘행동 목록’
2) 지연/드랍 상황에서 유지되는 행동 대체 경로
3) 로컬 반응과 서버 결과의 분리 기준
4) 성능 저하 시 우선 보호 대상 규칙
5) 성능 붕괴 여부 판별 체크리스트

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 어떤 환경에서도
  유저의 행동은 멈춰서는 안 된다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 모든 입력에는 로컬 1차 반응이 반드시 존재한다
  · 서버 응답과 무관하게
    버튼 눌림, 소리, 시각 반응은 즉시 발생
  → 입력 인식 여부는 절대 서버에 의존하지 않는다

- 기본 행동은 ‘프레임 드랍 상태’에서도 실행 가능해야 한다
  · 애니메이션 생략 가능
  · 연출 단순화 가능
  · 결과 지연 허용
  → 실행 불가 상태는 금지

- 성능 저하 시에도
  행동 가능 상태 UI는 유지된다
  · 로딩 화면으로 전환 ❌
  · 입력 잠금 ❌
  · 결과만 늦게 반영 ⭕

- 네트워크 불안정은
  행동 차단 사유가 될 수 없다
  · 오프라인/지연 상태에서도
    행동 큐잉 또는 임시 처리 허용
  → “아무것도 안 된다” 상태 금지

- 성능 차이는 보상 차이로 직접 연결되지 않는다
  · 느린 환경 = 손해 구조 ❌
  · 동일 시간 대비 행동 횟수 극단적 차이 ❌
  → 성능은 경쟁 요소가 아니다

2) 금지 규칙

- 성능 부족을 이유로
  행동 버튼을 비활성화 ❌

- 지연 상황에서
  입력 무시 또는 무반응 ❌

- 성능 문제를
  경고 메시지로 설명하는 UI ❌
  → 설명은 불안을 키운다

- 특정 기기에서만
  핵심 루프가 성립하는 구조 ❌

3) 조건부 허용 규칙

- 성능 저하 시
  시각 연출·이펙트 축소 ⭕
  → 단, 입력 반응은 유지

- 서버 결과 지연 시
  임시 결과 표시 ⭕
  → 단, 나중에 반드시 정합성 보정

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 목적은
  유저가 “지금은 못 한다”라고 느끼지 않게 만드는 것이다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- 네트워크 지연 시
  버튼 비활성화 + 로딩 스피너
  → 행동 단절, 즉시 이탈

❌ 금지 예시
- 저사양 기기에서
  첫 행동 자체가 늦게 발생
  → 온보딩 단계에서 탈락

⭕ 허용 예시
- 입력 즉시
  버튼 반응 + 소리 발생
  결과는 1~2초 후 적용
  → 체감 속도 유지

⭕ 허용 예시
- 프레임 저하 시
  이펙트 생략 + 결과 텍스트만 표시
  → 행동 흐름 유지

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 행동 가능 상태 < 연출 완성도
- 입력 반응 < 결과 정확성
- 저사양 안정성 < 고사양 비주얼
- 행동 연속성 < 서버 정합성 논쟁

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 성능 문제로 행동이 끊긴다면:
  → 기능을 줄이지 않는다
  → 표현을 단순화한다

- 네트워크가 불안정하다면:
  → 행동을 막지 않는다
  → 결과 반영을 늦춘다

- 저사양 유저 비중이 높아진다면:
  → 고사양 기준을 낮춘다
  → 하위 환경을 기준선으로 재설정한다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 프레임 드랍 상황에서도 기본 행동이 가능한가?
- 입력 후 무반응 상태가 존재하는가?
- 성능 차이가 성장/보상 차이로 증폭되는가?
- 네트워크 지연 시 대체 경로가 있는가?
- 저사양 기기에서도 첫 행동이 즉시 발생하는가?

→ 하나라도 No라면
  이 성능 대응 구조는 다시 설계되어야 한다
```



### 9. 업데이트·확장 계획

```
[섹션명]
- 업데이트·확장 계획
  – “시간이 지나도 행동 구조를 유지하는 확장 설계”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  콘텐츠를 계속 추가하는 것이 아니라,
  추가하더라도 기존 게임이 ‘다른 게임’이 되지 않게 하는 데 있다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 업데이트 이후 기본 행동 붕괴
  · 기존 유저의 근육 기억 무효화
  · 신규 시스템이 핵심 루프를 대체
  · 성장·경제·UI 규칙의 일관성 붕괴
  · “예전이 더 나았다”는 집단 이탈 발생

- 이 섹션은 다음 시스템을 정렬하는 기준이다:
  · 기본 행동: 추가 콘텐츠가 이를 대체하는가, 강화하는가
  · 성장 설계: 신규 성장축이 기존 체감을 무력화하는가
  · 경제 구조: 신규 재화가 기존 가치를 붕괴시키는가
  · UI/온보딩: 업데이트 후 설명이 필요해졌는가

→ 업데이트는 ‘추가’가 아니라
  **기존 구조를 시험하는 스트레스 테스트**다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 확장 가능 영역과 불변 영역의 구분표
2) 콘텐츠 추가 시 필수 검증 항목 목록
3) 신규 시스템의 핵심 루프 연결 방식
4) 업데이트 우선순위 판단 기준
5) 구조 붕괴 판별 체크리스트

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 새로운 콘텐츠는
  기존 행동 구조를 대체할 수 없다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 모든 신규 콘텐츠는
  기존 기본 행동을 ‘더 많이’ 혹은 ‘더 자주’
  하게 만드는 방향으로만 연결된다
  → 새로운 주행로는 허용, 우회로는 금지

- 신규 시스템은
  기존 시스템 위에 ‘겹쳐서’ 작동해야 한다
  · 병렬 루프 ❌
  · 독립 루프 ❌
  · 기존 루프 강화 ⭕

- 업데이트 후에도
  기존 유저는 설명 없이 플레이 가능해야 한다
  → 설명 필요 = 구조 실패 신호

- 신규 재화·아이템은
  기존 재화의 의미를 소멸시키지 않는다
  · 상위 재화로 대체 ❌
  · 전용 사용처 + 연결 보상 ⭕

- 업데이트는
  행동 빈도를 낮추지 않는다
  · 대기 시간 증가 ❌
  · 절차 추가 ❌
  · 행동 단축 ⭕

2) 금지 규칙

- “이제부터는 이걸 하세요” 구조 ❌
  → 기본 행동 교체는 전면 리디자인 사유

- 신규 콘텐츠로
  기존 콘텐츠가 무의미해지는 구조 ❌

- 고인물 전용 시스템이
  전체 경제를 잠식하는 구조 ❌

- 업데이트 이후
  튜토리얼 재강요 ❌

3) 조건부 허용 규칙

- 완전히 새로운 행동 추가 ⭕
  → 단, 기존 기본 행동이 여전히
    전체 행동의 과반을 차지할 것

- 신규 성장축 추가 ⭕
  → 단, 기존 성장 체감이 약화되지 않을 것

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 목적은
  시간이 지나도 유저가
  ‘익숙하게 계속할 수 있게’ 만드는 것이다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- 시즌 업데이트 후
  기존 사냥/플레이 가치 급감
  → 행동 붕괴, 복귀 유저 이탈

❌ 금지 예시
- 신규 모드가
  보상 효율에서 기존 모드를 압도
  → 사실상 강제 이동 발생

⭕ 허용 예시
- 신규 스테이지 추가
  → 기존 행동 동일, 환경·연출만 확장

⭕ 허용 예시
- 신규 아이템군 추가
  → 기존 재화 소모 + 기존 행동 반복으로 획득

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 구조 안정성 < 콘텐츠 다양성
- 기존 행동 유지 < 신규 재미
- 복귀 유저 이해도 < 신규 유저 흡입
- 장기 신뢰 < 단기 지표 상승

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 신규 콘텐츠가
  기존 행동보다 더 많이 반복된다면:
  → ‘확장’이 아니라 ‘핵심 교체’로 간주

- 업데이트마다
  설명이 늘어난다면:
  → 구조 복잡도가 임계점을 넘은 것

- 시스템이 커져
  판단 비용이 증가한다면:
  → 콘텐츠를 줄이고 구조를 고정한다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 업데이트 후에도 기본 행동은 동일한가?
- 신규 콘텐츠가 기존 루프를 강화하는가?
- 설명 없이 기존 유저가 바로 플레이 가능한가?
- 신규 재화가 기존 가치를 잠식하는가?
- 6개월 뒤에도 같은 구조로 확장 가능한가?

→ 하나라도 No라면
  이 업데이트 구조는 재설계되어야 한다
```



### 10. 로블록스 플랫폼 제약 이해

````
[섹션명]
- 로블록스 플랫폼 제약 이해
  – “행동 구조를 외부 규칙 속에서도 유지하는 안전 구조”

────────────────────────────────
[섹션 목적 (Why)]
────────────────────────────────
- 이 섹션의 목적은
  게임을 ‘잘 설계’하는 것이 아니라
  게임이 플랫폼에 의해 ‘존재 불가’ 상태가 되는 것을 막는 데 있다

- 이 섹션이 무너질 경우 발생하는 구조적 실패:
  · 게임 비공개 또는 삭제
  · 수익 정지 및 계정 제재
  · 업데이트 불가 상태 고착
  · 유저 데이터·신뢰의 강제 소멸
  · 운영 중단으로 인한 루프 붕괴

- 이 섹션은 다음 시스템을 강제 정렬한다:
  · UI/연출: 과도한 자극, 오인 유도 여부
  · 경제/가챠: 확률·과금·보상 구조의 합법성
  · 콘텐츠: 저작권 및 연령 적합성
  · 업데이트: 정책 변경 대응 가능성

→ 플랫폼 제약은 선택 사항이 아니라
  **모든 설계의 외부 경계 조건**이다

────────────────────────────────
[섹션 산출물 (Output)]
────────────────────────────────
이 섹션을 작성하고 나면
반드시 다음 결과물이 결정되어야 한다

1) 플랫폼 정책 대응 체크리스트
2) 위험 요소 분류표(삭제 / 제재 / 경고)
3) 확률·과금 구조 검증 기준
4) 콘텐츠 자산 사용 규칙
5) 운영 중 정책 변경 대응 절차

────────────────────────────────
A) 규칙 선언 (One-liner Rule)
────────────────────────────────
- 플랫폼 규칙을 위반하는 설계는
  존재 가치가 없다

────────────────────────────────
B) 세부 규칙 (Execution Rules)
────────────────────────────────

1) 실행 규칙

- 모든 콘텐츠는
  ‘저연령 유저 기준’으로 판단한다
  · 폭력성, 공포, 도박 연상 요소 최소화
  · 오해 소지 있는 표현 제거

- 확률형 시스템은
  결과보다 구조가 먼저 검증된다
  · 확률 표시 방식 명확화
  · 꽝의 정의 및 잔여 보상 구조 필수

- 과금 요소는
  플레이 진행을 막지 않는다
  · 결제 없이는 진행 불가 ❌
  · 시간 단축/편의 제공 ⭕

- 이미지·사운드·모델은
  출처와 사용 권한이 명확해야 한다
  · 외부 에셋 사용 시 라이선스 확인
  · AI 생성물도 동일 기준 적용

- 모든 업데이트는
  정책 변경 가능성을 고려해 설계한다
  · 즉시 수정·비활성화 가능한 구조 유지

2) 금지 규칙

- 실제 도박과 유사한 연출 ❌
  · 확률 은폐
  · 과도한 긴장 연출
  · 결과 조작 의심 구조

- 저작권 불명확 자산 사용 ❌

- 저연령에게
  과도한 구매 압박을 주는 설계 ❌

- 정책 위반 가능성을
  “걸리면 고친다”로 처리 ❌

3) 조건부 허용 규칙

- 확률형 보상 ⭕
  → 단, 실패 시 잔여 가치가 명확할 것

- 외부 IP 오마주 ⭕
  → 단, 식별 불가능 수준일 것

────────────────────────────────
C) 핵심 의도 (→)
────────────────────────────────
→ 이 섹션의 목적은
  게임이 언제든
  **계속 운영될 수 있는 상태를 유지**하는 것이다

────────────────────────────────
D) 금지 예시 / 허용 예시
────────────────────────────────

❌ 금지 예시
- 확률 공개 없는 뽑기 시스템
  → 즉시 제재 대상

❌ 금지 예시
- 유명 IP 캐릭터를
  식별 가능하게 차용
  → 저작권 분쟁 위험

⭕ 허용 예시
- 확률 명시 + 누적 보상 구조
  → 정책 적합 + 신뢰 유지

⭕ 허용 예시
- 자체 제작 에셋 + 명확한 테마
  → 장기 운영 가능

────────────────────────────────
E) 우선순위 규칙 (Conflict Resolution)
────────────────────────────────
- 재미 < 정책 적합성
- 수익성 < 계정 안전
- 연출 강도 < 저연령 보호
- 단기 성과 < 지속 운영

────────────────────────────────
F) 경계 조건 (Boundary Handling)
────────────────────────────────
- 정책 해석이 모호한 경우:
  → 더 보수적인 설계를 선택한다

- 정책 변경 가능성이 감지되면:
  → 해당 시스템을 즉시 분리·비활성화 가능하게 설계

- 제재 리스크가 누적될 경우:
  → 콘텐츠를 줄이고 구조를 단순화한다

────────────────────────────────
[섹션 판별 체크리스트 (Yes / No)]
────────────────────────────────
- 모든 시스템이 정책 위반 없이 설명 가능한가?
- 저연령 기준에서 오해 소지가 없는가?
- 확률·과금 구조가 투명한가?
- 저작권 출처가 명확한가?
- 정책 변경 시 즉시 대응 가능한가?

→ 하나라도 No라면
  이 게임은 플랫폼 리스크 상태다
````





## 게임 설명

- 장르: 「행동 기반 하이브리드 디펜스 RPG」  (Action-Driven Idle Defense RPG)

  “사냥이라는 단순 행동을 반복해 디펜스를 강화하고, 뽑기와 마켓은 행동을 끊지 않기 위한 보조 구조로만 작동하는 게임”



### 컨텐츠

1. 재화 얻기(사냥)
2. 뽑기 시스템
3. 아이템창
4. 마켓
5. 디펜스



#### 1. 재화 얻기(사냥)

##### 콘텐츠 기획

```
====================================================
1. 재화 얻기(사냥) 콘텐츠 기획서 (핵심 루프 기반)
====================================================
1) 사냥의 본질적 정의
- 사냥은 전투 콘텐츠가 아니라 게임의 기본 입력 장치다
- 재화를 발생시키는 가장 단순하고 반복 가능한 행동이다
- 뽑기, 아이템, 마켓, 디펜스의 진입점 역할을 한다
- 아무 설명 없이도 즉시 실행 가능해야 한다

2) 사냥의 역할
- 다른 시스템을 이해하지 못해도 항상 할 수 있는 행동 제공
- 반복만으로 성장하고 있다는 체감 제공
- 실패 후에도 돌아올 수 있는 안전 지점 역할
- 게임 전체 리듬을 유지하는 핵심 루프 유지 장치

3) 사냥의 기본 흐름
- 사냥 시작 → 즉시 입력 반응
- 자동 또는 반자동 전투 진행
- 몬스터 처치
- 재화 즉시 획득
- 다음 행동(뽑기/디펜스/마켓) 1개 강조

4) 사냥 보상 구조
- 기본 재화
  · 모든 사냥에서 확정 지급
  · 뽑기의 기본 연료
- 보조 재화
  · 확률 또는 조건부 지급
  · 강화 재료, 디펜스 재료, 마켓 거래용 아이템
- 꽝 사냥 금지
- 적은 보상은 허용, 무보상은 금지

5) 사냥 난이도 설계
- 조작 난이도 없음
- 실패 페널티 없음
- 사망 시 즉시 재개 가능
- 난이도 표현은 체력, 처치 속도, 연출 강도로만 변화

6) 성장 체감 설계
- 공격 이펙트 크기 증가
- 공격 속도 상승
- 타격 반응 강화(진동, 히트스톱)
- 몬스터 반응 과장
- 숫자 설명 없이 체감 중심 설계

7) 사냥 지속 장치
- 연속 사냥 시 보상 효율 증가
- 중단 시 즉시 리셋 금지, 점진적 감소만 허용
- 엘리트 몬스터 랜덤 등장
- 연속 실패 시 자동 보정 시스템 적용

8) 다른 콘텐츠와의 연결
- 사냥 종료 후 반드시 다음 행동 1개 강조
- 뽑기 가능 상태 즉시 노출
- 디펜스 설치 또는 강화 진입 유도
- 마켓 등록 가능 상태 노출
- 사냥 후 멈춤 상태 금지

9) 사냥 UI 원칙
- 사냥 버튼은 항상 가장 크고 눈에 띄는 위치
- 버튼 위치 고정
- 입력 후 0.1초 이내 1차 피드백 제공
- 실패/무효 입력에도 반응 제공
- 텍스트 설명 없이 시각적 유도로 구성

10) 성공 판별 기준
- 사냥만으로 게임 진행이 가능한가?
- 실패 후 가장 먼저 누르는 버튼이 사냥인가?
- 설명 없이 바로 시작되는가?
- 사냥 후 다음 행동이 자연스럽게 이어지는가?

- 하나라도 충족되지 않으면 사냥 구조 재설계 필요
```

##### 개발 전 필수 검토 체크리스트

```
[재화 얻기(사냥) 개발 전 필수 검토 체크리스트]

1. 재화 권한 주체 결정
- 재화 지급/계산은 서버 권한으로만 처리
- 클라이언트는 입력·연출만 담당
- 클라 기준 보상 확정 구조는 금지

2. 사냥 1회 트랜잭션 정의
- 사냥 시작 시점 명확화
- 보상 계산 시점 명확화
- 보상 지급 시점 명확화
- 저장 주기 결정(즉시 저장 금지, 묶음 처리 권장)

3. 재화 획득 속도 상한선
- 이론적 분당 최대 획득량 정의
- 반복 효율 감소 구조(diminishing returns) 설계
- 서버 기준 획득 빈도 감시

4. 악용·자동화 대응 기준
- 분당 사냥 횟수 감시
- 평균 사냥 소요 시간 감시
- 입력 패턴 반복성 감시
- 차단보다 보상 완화 방식 우선 적용

5. 실패·중단 상황 처리
- 네트워크 끊김 시 최소 보상 보존
- 앱 종료 시 마지막 정상 상태 기준 복구
- 손실 대신 지연 지급 구조 선택

6. 재화 타입 분리 설계
- 즉시 소비 재화
- 누적 성장 재화
- 교환·보조 재화
- 재화별 저장 주기 및 증감 규칙 분리

7. 클라이언트 연출 vs 서버 판정 불일치 대응
- 클라 연출은 항상 성공처럼 처리
- 서버 판정 차이는 보상량으로만 반영
- 처치 실패 메시지 노출 금지

8. 로그 및 추적 설계
- 사냥 시작/종료 로그
- 지급 재화량 로그
- 서버 판정 시간 로그
- 비정상 패턴 플래그 기록

[핵심 원칙]
- 재화 시스템은 재미 이전에 신뢰 시스템이다
- 권한·저장·상한·복구를 먼저 고정한다
- 이 항목 중 하나라도 미정이면 전체 경제 구조는 붕괴한다
```

##### 아직 정의되지 않은 핵심 항목들 

```
[아직 정의되지 않은 핵심 항목들 (Design Lock 미완 지점)]

A. 사냥(재화 획득) 루프의 “시간 단위” 정의 미흡
1) 사냥 1회의 기준 시간(초)
- 1회 사냥이 평균 몇 초짜리 행동인가?
- 전투/이동/연출 포함 여부는?
- 자동 반복(오토)인가, 입력 기반 반복인가?

2) 사냥 루프의 리듬(템포)
- “사냥 시작 → 처치 → 보상 지급”까지 목표 RTT(총 소요시간)
- 유저가 1분 동안 반복 가능한 평균 횟수(목표치)
- 레벨/스탯 성장에 따라 사냥 시간이 어떻게 변하는가?

3) 사냥 트랜잭션 타이밍(서버 기준)
- 사냥 시작 시점: 입력 순간? 몬스터 스폰 순간? 첫 타격 순간?
- 종료 시점: 처치 순간? 보상 지급 완료 순간? 루프 재시작 순간?
- 보상 확정 시점: 처치 직후? 일정 주기 묶음 처리 시?

────────────────────────────────

B. 실패/불일치 처리의 “수치 규칙”이 미정
1) 실패 정의
- 실패란 무엇인가?
  (사망? 시간 초과? 타격 미달? 네트워크 끊김? 입력 없음?)

2) 실패 시 보상 감소 비율
- 실패 보상은 기본 보상의 몇 %인가? (예: 70%, 50%, 10% 등)
- 실패의 종류별 차등이 있는가? (사망 vs 중단 vs 네트워크)

3) 연속 실패 보정(자동 보정 시스템)
- 보정 발동 조건: 연속 실패 n회? 일정 시간 무득점?
- 보정 방식: 드랍 확률 상승? 기본 보상 증가? 적 약화?
- 보정 상한/하한: 최소 보장치(바닥값)와 최대 보정치(천장값)

4) “클라 연출은 항상 성공처럼” 처리 시 서버 판정 차이 반영 규칙
- 차이는 보상량으로만 반영한다면:
  - 보상량 감소 폭은 어느 수준까지 허용?
  - 유저가 ‘손해’를 체감하지 않게 만드는 최소치(바닥값)는?

────────────────────────────────

C. 사냥 → (뽑기/디펜스/마켓) 전이(Next Action) “강제성 수준” 미정
1) 다음 행동 1개 강조의 강도
- 단순 강조(UI 하이라이트)인가?
- 버튼 점멸/사운드/진동 같은 강한 유도인가?
- 일정 조건 충족 시 자동 화면 전환(강제 이동)까지 하는가?

2) 전이 트리거(발동 조건)
- 몇 회 사냥 후? (n회)
- 특정 재화량 도달 시?
- 특정 아이템 드랍 시?
- 특정 레벨업 이벤트 시?

3) 전이 실패/거부 처리
- 유저가 다음 행동을 무시하고 계속 사냥만 하면:
  - 계속 허용?
  - 점진적 유도 강화?
  - 보상 효율 감소(강제 경제 유도)?
  - 특정 구간에서만 잠금/강제?

────────────────────────────────

D. 재화 경제 상수(밸런스) — 수치 잠금 미정
1) 재화 타입별 목표 획득량
- 기본 재화: 분당 목표량/상한선
- 보조 재화: 분당 목표량/드랍 확률/천장(피티) 유무

2) Diminishing Returns(효율 감소) 구체 규칙
- 어떤 조건에서 감소가 시작되는가? (연속 사냥 시간/횟수)
- 감소 곡선 형태: 선형/지수/계단식?
- 감소 최대치(최저 효율)는?

3) 연속 사냥 보너스 규칙
- 보너스 증가율/상한
- 중단 시 감소 방식: 즉시 리셋 금지라고 했으니 “얼마나 천천히 감소”하는지

────────────────────────────────

E. 악용 탐지 기준의 “임계치” 미정
1) 분당 사냥 횟수 임계치
- 정상 상한(soft limit) / 비정상 상한(hard limit) 수치

2) 평균 사냥 소요 시간 임계치
- 너무 빠른 사냥(비정상) 판정 기준

3) 입력 패턴 반복성 기준
- 반복성 점수/윈도우 크기/플래그 조건(정확 수치)

4) “차단보다 보상 완화” 방식의 구체 패널티
- 완화 비율/지속 시간/회복 조건

────────────────────────────────

F. 저장/복구 정책의 구체 주기 미정
1) 즉시 저장 금지라면:
- 몇 회 사냥마다 저장? (n회)
- 몇 초마다 저장? (t초)
- 종료/이탈 시 강제 플러시 조건?

2) 네트워크 끊김/앱 종료 시 “최소 보상 보존”의 범위
- 마지막 저장 이후 획득분을 얼마나 인정?
- 인정 방식: 지연 지급 큐? 임시 버퍼? 재접속 시 정산?

────────────────────────────────

[요약: 개발 착수 전 잠금해야 하는 3대 축]
- 시간 단위(사냥 1회의 템포/트랜잭션)
- 수치 규칙(실패/보정/경제 상수)
- 전이 규칙(사냥 → 다음 행동 강제성/트리거)
```
